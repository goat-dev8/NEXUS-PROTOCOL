



We are building **NEXUS PROTOCOL** for Polygon Buildathon Wave 3.

-------------------------------------------------
HIGH-LEVEL IDEA
-------------------------------------------------
NEXUS Protocol = "The Invisible Yield Layer"

Core themes:
- Privacy-first DeFi on Polygon
- Deep stablecoin liquidity (USDC/USDT) aggregated from real DeFi protocols
- Stealth payments via @username
- ZK identity hooks (for future integration)
- All visible in a beautiful React frontend (already generated via Lovable.dev)

Judges love:
- Privacy & ZK (Nxtlvl)
- Stablecoin & payments
- Deep, productive liquidity like Katana
- AI / infra
- Real utility, no fake dashboards

So NEXUS Protocol will be:
- A Polygon-native onchain product:
  - A yield vault contract (NexusVault) for stablecoins.
  - A stealth username registry + payment contract (StealthRegistry).
  - Optional governance token (NexusToken) for DAO vibes (low priority for Wave 3).
- A React frontend that:
  - Connects wallet on Polygon mainnet (chainId 137).
  - Shows real wallet balances (MATIC, USDC, vault shares).
  - Lets users deposit/withdraw from the vault.
  - Lets users register @usernames and send “stealth” payments using our StealthRegistry.
- **No backend / DB for this wave.**
  - Everything is either:
    - Smart contracts on Polygon mainnet
    - Direct HTTP calls from the frontend to public APIs (DeFiLlama, CoinGecko, etc.), if needed.
  - No Node.js server, no Prisma, no Postgres in this iteration.

-------------------------------------------------
CURRENT REPO STATE
-------------------------------------------------
- Root folder: this workspace (NEXUS PROTOCOL)
- Contains at least:
  - `web/` – Vite + React + TypeScript frontend generated by Lovable.dev using the prompt I provided. It includes:
    - Landing page `/`
    - App pages under `/app`: Dashboard, Vaults, Stealth Pay, AI Agent, Portfolio, Governance, Identity, Settings
    - TailwindCSS, Framer Motion, React Router, React Query, Zustand, wagmi/viem placeholders, etc.

There is currently:
- NO `contracts/` folder
- NO backend
- NO Hardhat/Foundry setup

We are about to:
- Add a `contracts/` folder (Hardhat + Solidity + TypeScript scripts preferred).
- Generate TypeChain typings so the frontend can import ABIs and contract types.
- Wire the frontend to call real contracts on Polygon mainnet.

-------------------------------------------------
ARCHITECTURE FOR THIS WAVE
-------------------------------------------------
Packages:
- `web/` – existing Vite React app (frontend only).
- `contracts/` – new Hardhat project with:
  - `contracts/src/NexusVault.sol`
  - `contracts/src/StealthRegistry.sol`
  - (Optionally) `contracts/src/NexusToken.sol` and `contracts/src/ZKIdentityStub.sol`
  - TypeScript deployment scripts for Polygon mainnet.

Key contracts & features (Wave 3 must-haves):
1) NexusVault (USDC vault)
   - ERC4626-style vault over **native USDC on Polygon**:
     - Native USDC address on Polygon PoS: `0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359`
   - Users can:
     - Deposit USDC and receive vault shares.
     - Withdraw USDC by burning shares.
   - For Wave 3:
     - Keep the yield mechanism simple and safe (it can just hold USDC; “yield” can be simulated by the owner depositing extra USDC into the vault or by integrating Aave v3 in a controlled way).
   - Emit clean events for deposits/withdrawals so frontend can display real onchain activity.
   - No reentrancy vulnerabilities (use OpenZeppelin + ReentrancyGuard).

2) StealthRegistry (username + stealth payments)
   - Mapping: `username -> meta` including owner address and some bytes (spending/viewing pubkeys as bytes for now).
   - Mapping: `address -> username` (reverse lookup).
   - Stealth payments:
     - For Wave 3: a simpler “stealth-ish” model is enough:
       - User registers a username and a target wallet (stealth address).
       - Sender calls `sendPayment(username, token, amount)`:
         - Contract transfers ERC20 from sender to the recipient’s registered wallet.
         - Emits a StealthPayment event with minimal metadata.
   - Username constraints: 3–20 chars, [a-z0-9_].
   - Use real ERC20 transfers (USDC/USDT) via IERC20.
   - This is “real” because:
     - Uses actual Polygon mainnet tokens.
     - Actually transfers real stablecoins between wallets.
     - Records all events onchain.

3) ZK identity
   - For this wave, just a **stub contract**:
     - `ZKIdentityStub.sol` that holds `mapping(address => bool isVerified)` plus admin setter.
     - Later we can swap this with real Polygon ID / Privado verifier.
   - Frontend only needs to:
     - Read `isVerified` for the user’s address.
     - Optionally show a button that would, in the future, trigger a verification flow.

We will NOT:
- Build any offchain AI agent or heavy AI backend this wave.
- Build a Node/Express backend.
- Build a database layer.

AI/“smart” parts for this wave:
- Can be basic heuristics computed in the browser (e.g. “which vault APY is higher”).
- Or basic calls from frontend to public APIs (DeFiLlama, CoinGecko) for read-only yield/price info.

-------------------------------------------------
NETWORKS & DEPLOYMENT
-------------------------------------------------
- Target network: **Polygon PoS mainnet (chainId 137)**.
- Optionally we can include Amoy testnet config, but for this wave we assume mainnet deployment for demo.
- RPC will come from `.env` (e.g., Alchemy or Infura Polygon URL).
- Private key:
  - Must NEVER be hard-coded.
  - Must be read from `.env` (e.g., `PRIVATE_KEY` variable).
  - I will provide the value locally; do NOT print it or commit it.

We will deploy:
- NexusVault
- StealthRegistry
- ZKIdentityStub (optional but recommended)
- (NexusToken only if there is time; front-end integration is low priority.)

-------------------------------------------------
FRONTEND INTEGRATION REQUIREMENTS
-------------------------------------------------
We want the frontend to:
- Use `wagmi` + `viem` configured for Polygon mainnet.
- Read RPC URL from environment (e.g. `VITE_POLYGON_RPC_URL`).
- Expose a “Connect Wallet” UX.
- Detect wrong network (show warning if not on Polygon 137).
- For Dashboard:
  - Show connected wallet address (shortened).
  - Show native MATIC balance.
  - Show USDC balance.
  - Show NexusVault share balance and underlying deposited amount by calling vault’s view functions.
- For Vaults page:
  - Show live data from the actual NexusVault contract:
    - TVL (totalAssets).
    - User deposit amount.
  - Allow:
    - Approving USDC spend for NexusVault.
    - Depositing USDC.
    - Withdrawing USDC.
  - No mock values for balances or TVL; everything should come from contract calls.

- For Stealth Pay page:
  - Allow registering a username via StealthRegistry.
  - Show current registered username for connected wallet (if any).
  - Allow sending a payment:
    - Input: `@username`, token (USDC), amount.
    - Flow:
      1. Approve USDC to StealthRegistry if needed.
      2. Call `sendPayment` on StealthRegistry.
  - Show recent payments by reading past events from StealthRegistry (optional but nice).

- NO backend API calls for core flows.
- External HTTP calls only from frontend (e.g. public price APIs if needed), not required for main functionality.

-------------------------------------------------
YOUR GENERAL BEHAVIOR
-------------------------------------------------
For all future prompts in this workspace:
- Prefer Hardhat + Solidity 0.8.20+ for contracts.
- Prefer TypeScript for any scripts/config.
- Use OpenZeppelin libraries for security.
- Never hardcode secrets or private keys.
- Use real addresses for:
  - Native USDC on Polygon: 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359
- Comment code clearly, as this is a Buildathon project judges will read.
- Favor simple, auditable logic over fancy complexity.

First task right now:
1) Scan the `web/` folder:
   - Summarize the existing pages, routes, and key components that Lovable.dev generated.
   - Identify which specific components/pages will need to call:
     - NexusVault contract
     - StealthRegistry contract
   - Suggest any small refactors (e.g., hooks, lib modules) that will make it easier to plug in wagmi/viem and real contract calls.

Do NOT write or change any files yet. Just respond with a clear summary and a short plan.

Let Copilot answer that first. Then move to the follow-up prompts below.

3. Copilot Prompt 2 – Set up contracts/ with Hardhat
After Copilot has summarized the frontend, send this from the project root:
Now set up the `contracts/` Hardhat project for NEXUS Protocol.

Goals:
- Add a `contracts/` folder at the repo root.
- Use Hardhat + TypeScript + Ethers v6 + TypeChain.
- Keep it self-contained and focused on deploying to Polygon.

Concrete tasks:

1) Initialize Hardhat project in `contracts/`:
- Create `contracts/package.json` with scripts:
  - `"compile"`, `"test"`, `"clean"`, `"deploy:amoy"`, `"deploy:polygon"`.
- Install dependencies:
  - `hardhat`
  - `@nomicfoundation/hardhat-toolbox`
  - `typescript`, `ts-node`, `tsconfig-paths`
  - `dotenv`
  - `@typechain/hardhat`, `typechain`
  - `@ethersproject/abi`, `@ethersproject/providers` OR Ethers v6 + TypeChain support.
  - `@openzeppelin/contracts`

2) Hardhat config:
- Create `contracts/hardhat.config.ts`:
  - Solidity version: ^0.8.20
  - Networks:
    - `amoy` with RPC from `process.env.AMOY_RPC_URL`
    - `polygon` with RPC from `process.env.POLYGON_RPC_URL`
    - Use `PRIVATE_KEY` from env for accounts if present.
  - TypeChain config:
    - Output dir: `./typechain-types`
    - Target: `ethers-v6`
  - Include toolbox plugins.

3) Env example:
- Create `contracts/.env.example` with:
  - `POLYGON_RPC_URL=https://polygon-mainnet.g.alchemy.com/v2/YOUR_KEY`
  - `AMOY_RPC_URL=https://polygon-amoy.g.alchemy.com/v2/YOUR_KEY`
  - `PRIVATE_KEY=0xYOUR_DEV_PRIVATE_KEY`
- DO NOT hardcode any real key.

4) Basic folder structure:
- `contracts/contracts/` for Solidity files.
- `contracts/scripts/` for deployment scripts.
- `contracts/test/` for tests.
- Add a minimal sample contract (e.g. `contracts/contracts/Placeholder.sol`) that we will later replace, just to ensure `npx hardhat compile` works.

After this task:
- Show me the final folder tree under `contracts/`.
- Show me `hardhat.config.ts` and `contracts/.env.example`.
- Do not yet implement NexusVault or StealthRegistry – that’s the next step.


4. Copilot Prompt 3 – Implement NexusVault & StealthRegistry contracts
After Hardhat skeleton is ready and compiles, run this from contracts/:
Now implement the core NEXUS Protocol contracts for Wave 3.

We need two main contracts for now:
1) `NexusVault.sol`
2) `StealthRegistry.sol`
Optionally 3) `ZKIdentityStub.sol` as a simple verifier stub.

Place them under `contracts/contracts/`.

----------------------------
Contract 1 — NexusVault.sol
----------------------------
Requirements:
- Solidity ^0.8.20
- Inherit from OpenZeppelin:
  - ERC20
  - ERC4626
  - Ownable
  - ReentrancyGuard
- Use native USDC on Polygon as the underlying asset:
  - Address: 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359
  - But make the asset address configurable via constructor, so we can reuse on other assets if needed.
- Behave as a standard ERC4626 vault:
  - Users `deposit(uint256 assets, address receiver)` to receive shares.
  - Users `withdraw(uint256 assets, address receiver, address owner)` to redeem shares.
- For now, no external Aave integration in code – just hold the asset and apply simple fee mechanics.
- Fees:
  - `depositFeeBps` and `withdrawFeeBps` (basis points, max 10%).
  - Fees are collected to a `treasury` address.
  - Owner can set fees within bounds.
- Limits:
  - Optional `totalDepositCap` in underlying tokens.
  - Owner can update cap.
- Events:
  - `event NexusDeposit(address indexed user, uint256 assets, uint256 shares);`
  - `event NexusWithdraw(address indexed user, uint256 assets, uint256 shares);`
- Security:
  - Use ReentrancyGuard on state-changing external functions.
  - Use SafeERC20 for token transfers.

Keep the implementation straightforward and well-documented with comments.
We don’t need strategy/yield logic yet for Wave 3: yield can be “0” from the contract’s perspective.

----------------------------
Contract 2 — StealthRegistry.sol
----------------------------
Purpose:
- Username registration and “stealth-style” stablecoin payments.

Requirements:
- Solidity ^0.8.20
- Use OpenZeppelin Ownable and ReentrancyGuard.
- Use a standard IERC20 interface.

Features:
1) Username registry:
   - `mapping(string => address) public usernameOwner;`
   - `mapping(address => string) public addressUsername;`
   - Constraint:
     - Username length 3–20 characters.
     - Allowed chars: lowercase letters [a-z], digits [0-9], underscore `_`.
   - Function:
     - `registerUsername(string calldata username)`:
       - Require that caller does not already have a username.
       - Require username not taken.
       - Validate characters.
       - Store mappings.
       - Emit `UsernameRegistered(username, msg.sender);`
   - Event:
     - `event UsernameRegistered(string indexed username, address indexed owner);`

2) Stealth-ish payments:
   - For Wave 3, keep it simple:
     - Each username implicitly routes to `usernameOwner[username]` wallet.
   - Function:
     - `sendPayment(string calldata username, address token, uint256 amount)`:
       - Require that username exists.
       - Require amount > 0.
       - Use IERC20(token).transferFrom(msg.sender, usernameOwner[username], amount).
       - Emit `StealthPaymentSent(msg.sender, username, token, amount);`
   - Event:
     - `event StealthPaymentSent(address indexed sender, string indexed username, address indexed token, uint256 amount);`

3) Admin:
   - Owner can set a minimal `registrationFee` in native MATIC to prevent spam.
   - If `registrationFee > 0`, `registerUsername` must be payable and require `msg.value >= registrationFee`.
   - Owner can withdraw accumulated MATIC to treasury.

Notes:
- Keep this implementation deliberately simpler than a full EIP-5564 stealth address scheme.
- It’s still “real”: uses real ERC20 transfers on Polygon mainnet and actual usernames stored onchain.
- Add comments where a future stealth meta-address / viewing key extension would be added.

----------------------------
Optional Contract — ZKIdentityStub.sol
----------------------------
A minimal stub to simulate ZK-based verification:

- `mapping(address => bool) public isVerified;`
- `event IdentityVerified(address indexed user);`
- `function setVerified(address user, bool status) external onlyOwner;`

We will just read `isVerified` from the frontend and treat it as a future hook for an actual ZK verifier.

----------------------------
Tests & TypeChain
----------------------------
- Add minimal tests in `contracts/test/`:
  - For NexusVault:
    - Deploy a mock ERC20 (for tests only).
    - Deploy NexusVault using the mock asset.
    - Test deposit/withdraw with fees and cap.
  - For StealthRegistry:
    - Deploy mock ERC20.
    - Register a username.
    - Transfer some tokens to a user, approve registry, send payment, assert balances.

- After implementing contracts:
  - Ensure `npx hardhat compile` works.
  - Ensure `npx hardhat test` runs basic tests.
  - Generate TypeChain typings via `npx hardhat typechain` or the configured task.

Make all these changes now and show me:
- Contract file paths.
- Main public functions and events for each contract.


5. Copilot Prompt 4 – Deployment scripts for Polygon mainnet
After contracts compile and basic tests pass, create deployment scripts:
Now create deployment scripts for Amoy testnet and Polygon mainnet and wire addresses for the frontend.

Goals:
- Easily deploy NexusVault, StealthRegistry, and ZKIdentityStub to:
  - Amoy (for cheap testing)
  - Polygon mainnet (for final demo)
- Store deployed addresses in JSON so the frontend can read them.

Tasks:

1) In `contracts/scripts/`, create:
   - `deploy-nexus.ts`

Behavior of `deploy-nexus.ts`:
- Use Hardhat Runtime Environment in TypeScript.
- Steps:
  1. Read `POLYGON_RPC_URL`, `AMOY_RPC_URL`, and `PRIVATE_KEY` from `process.env`.
  2. Deploy:
     - `ZKIdentityStub` (optional but recommended).
     - `NexusVault`, passing:
       - Underlying asset address for USDC:
         - For mainnet: 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359
         - For Amoy: use a configurable env (e.g., `AMOY_USDC_ADDRESS`) or a mock token you deploy in tests only.
     - `StealthRegistry`.
  3. Log final deployed addresses.
  4. Write them into a JSON file at:
     - `contracts/deployments/<network>.json`
     Example:
     {
       "network": "polygon",
       "nexusVault": "0x...",
       "stealthRegistry": "0x...",
       "zkIdentityStub": "0x..."
     }

2) Hardhat tasks:
- In `hardhat.config.ts` or a separate tasks file, add npm scripts in `contracts/package.json`:
  - `"deploy:amoy": "hardhat run --network amoy scripts/deploy-nexus.ts"`
  - `"deploy:polygon": "hardhat run --network polygon scripts/deploy-nexus.ts"`

3) Env usage:
- Ensure the script does NOT expose or print the private key.
- Use signer from Hardhat’s `ethers.getSigners()` (which will use the `PRIVATE_KEY` configured for that network).

4) After script implementation:
- Show me sample console output you’d expect when running:
  - `pnpm --filter contracts deploy:amoy`
  - `pnpm --filter contracts deploy:polygon`
- Show the shape of `deployments/polygon.json` and `deployments/amoy.json`.

Do not run any commands; just implement the script and configs.

You will then manually:

* Create a real .env inside contracts/ (not committed) with your Polygon RPC and a fresh dev PRIVATE_KEY.
* Run the deploy scripts yourself when ready.


6. Copilot Prompt 5 – Frontend wiring: wagmi, env, balances, vault, stealth
Now we plug the contracts into the existing web/ app. From the project root, tell Copilot to work inside web/:
Now wire the NEXUS Protocol frontend (`web/`) to the real contracts and Polygon mainnet.

Constraints:
- No backend, no database.
- Only frontend + contracts.
- All real data:
  - Wallet balances from onchain.
  - Vault TVL and shares from NexusVault contract onchain.
  - Stealth pay actions via StealthRegistry contract.

Inputs:
- The `contracts/deployments/*.json` files created earlier contain the addresses for:
  - `nexusVault`
  - `stealthRegistry`
  - `zkIdentityStub` (optional)
- We will add a simple config file in `web/` that reads those addresses.

Tasks:

1) Frontend env + config
- In `web/`, create `.env.example` with:
  - `VITE_POLYGON_RPC_URL=https://polygon-mainnet.g.alchemy.com/v2/YOUR_KEY`
  - `VITE_NEXUS_VAULT_ADDRESS=0x...` (to be filled after deploy)
  - `VITE_STEALTH_REGISTRY_ADDRESS=0x...`
  - `VITE_ZK_IDENTITY_ADDRESS=0x...` (optional)
- Add a `web/src/lib/config.ts` file that:
  - Reads `import.meta.env` and exports:
    - `rpcUrl`
    - `nexusVaultAddress`
    - `stealthRegistryAddress`
    - `zkIdentityAddress`

2) Wagmi + viem setup
- Ensure `wagmi` + `viem` are installed.
- Create `web/src/lib/wallet.tsx`:
  - Configure `WagmiConfig` + `QueryClientProvider` if not already.
  - Set default chain to Polygon mainnet (chainId 137).
  - Use `VITE_POLYGON_RPC_URL` as the public client RPC.
- Wrap the app in this provider in `main.tsx`.

3) Contract bindings
- From `contracts/`, copy or export TypeChain types & ABIs for:
  - NexusVault
  - StealthRegistry
- In `web/src/lib/contracts.ts`:
  - Import ABIs and addresses.
  - Export helper functions or constants usable with `wagmi` / `viem`:
    - `nexusVaultConfig = { address, abi }`
    - `stealthRegistryConfig = { address, abi }`

4) Wallet & balances
- Implement a hook `web/src/hooks/useWallet.ts` (if not already):
  - Use `wagmi` hooks to:
    - Get the connected account.
    - Get native MATIC balance.
  - Expose `{ address, ensName, balance, isConnected, connect, disconnect }`.

- On the main Dashboard page:
  - Show connected wallet address or “Connect Wallet” button.
  - Show:
    - Native MATIC balance.
    - USDC balance via ERC20 `balanceOf` (use viem readContract).

5) Vault integration
- Implement a hook `web/src/hooks/useNexusVault.ts`:
  - Uses `nexusVaultConfig`:
    - `totalAssets` (tvl).
    - `balanceOf(user)` and `convertToAssets(shares)` to show user deposit.
  - For actions:
    - `deposit(amount)`:
      1. Call ERC20 `approve` on USDC for `nexusVaultAddress` if needed.
      2. Call `deposit` on NexusVault with `amount` (in smallest units).
    - `withdraw(amount)`:
      1. Calculate required shares via `convertToShares`.
      2. Call `withdraw`.
  - Expose loading and error states.

- Wire this hook into:
  - The Vaults page (`/app/vaults`):
    - Replace mock vault card with real NexusVault data for at least one vault.
    - Display:
      - TVL from `totalAssets` (formatted in USDC).
      - User deposit.
      - Simple estimated APY (can be a constant or computed from onchain over time later).

6) Stealth Pay integration
- Implement a hook `web/src/hooks/useStealthRegistry.ts`:
  - Read:
    - Current username for connected address via `addressUsername`.
    - Availability of a username via a function `isUsernameAvailable` (if you add it) or by reading owner and comparing to zero address.
  - Write:
    - `registerUsername(username)` which:
      - Calls `registerUsername` on StealthRegistry.
    - `sendPayment(username, tokenAddress, amount)` which:
      - Approves the ERC20 if required.
      - Calls `sendPayment` on StealthRegistry.

- Wire into `/app/stealth` page:
  - “Your @username” section:
    - Show existing username or button/form to register.
  - “Send Stealth Payment” form:
    - Recipient: `@username`
    - Token selector: start with USDC only (enforce token address).
    - Amount input.
    - On submit:
      - Connect wallet if not connected.
      - Execute the sendPayment flow.
      - Show transaction hash / success toast.

7) Identity status (optional but nice)
- On `/app/identity` page:
  - If `zkIdentityAddress` is set:
    - Read `isVerified(address)` via viem.
    - Show “Verified” or “Not Verified”.
  - Add a placeholder button “Mark as Verified (Admin Only)” that would call `setVerified` if the caller is owner (for now, just hide this from normal users or mark as dev-only).

8) UX & Error handling
- Reuse existing notification/toast component (if Lovable created one) or create a simple global toast provider.
- For every onchain action:
  - Show “Transaction pending…”.
  - On success, show “Success”.
  - On error, show readable error.

Make these changes carefully:
- Do not destroy existing UI design from Lovable.
- Replace mock data progressively with real onchain calls.
- Ensure the app still builds with `pnpm run build` (or `npm run build`) from `web/`.


7. Copilot Prompt 6 – Prepare for Vercel deploy (SPA, no backend)
Finally, once everything works locally, set up Vercel‑friendly config:
Last step: make the `web/` app ready for deployment to Vercel as a static SPA.

Tasks:
1) Ensure the build output is a standard Vite SPA:
   - Confirm `web/vite.config.ts` uses correct `base` and `build` options (defaults are usually fine).
2) Add a `vercel.json` at the project root or inside `web/` (depending on best practice) that:
   - Treats it as a SPA:
     - Rewrites all paths to `/index.html` so routes like `/app/vaults` work directly.
   Example:
   {
     "rewrites": [
       { "source": "/(.*)", "destination": "/" }
     ]
   }

3) Document in `web/README.md`:
   - Build command: `npm run build`
   - Output directory: `dist`
   - Required env vars on Vercel (non-secret):
     - `VITE_POLYGON_RPC_URL`
     - `VITE_NEXUS_VAULT_ADDRESS`
     - `VITE_STEALTH_REGISTRY_ADDRESS`
     - `VITE_ZK_IDENTITY_ADDRESS` (if used)

Do not add any backend config; this is a frontend-only deploy.


